<html>
<head>
<title>Scripted Testing</title>
<link href="sf.css" rel="stylesheet" type="text/css"/>
</head>
<body>

<div id="header">
<a
href="http://sourceforge.net"><img
src="http://sourceforge.net/sflogo.php?group_id=135558&amp;type=1"
width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
</div>

<h1>Scripted Testing</h1>

<h2>Introduction</h2>

<p>To set the scene, the Ada software under test (SUT) forms part of a
system. Generally, the system will be constructed using a layered
approach, and the other parts of the system that interact with the SUT
are higher-level (which can call interface subprograms presented by
the SUT) or lower-level (whose interfaces can be called by the SUT, or
which can provide callbacks to the SUT).

<p>This package is intended for testing at a level between unit
testing (using, for
example, <a href="http://libre.adacore.com/tools/aunit/">AUnit</a>)
and integration testing (using real hardware). Unit testing tends to
be fragile, requiring a lot of rework for even minor functional
changes in the requirements.

<p>The scripting language supported
is <a href="http://www.tcl.tk">Tcl</a>, and specifically the Ada
binding <a href="http://sourceforge.net/projects/tcladashell/">TclAdaShell</a>. The
reason for choosing Tcl rather than Python or Lua is that Tcl's
interface is entirely string-based; this is important, considering the
need to specifiy values of enumerated types.

<p>The package provides facilities to write new commands in Tcl to

<ul>

<li> call the interface subprograms presented by the SUT,

<li> set up values to be returned by calls the SUT makes to
lower-level system components,

<li> call callbacks provided by lower-level system components,

<li> delay for appropriate periods, and

<li> check that the proper calls have been made to lower-level system
components, with the required values.

</ul>

<p>It's assumed that the interface subprograms of the lower-level
subsystems are stubbed so that:

<ul>

<li> <tt>in</tt> and <tt>in out</tt> parameters can be recorded for later
checking,

<li> <tt>out</tt> (and <tt>in out</tt>) parameter values and
function <tt>return</tt> values can be provided to be returned to the
SUT,

<li> exceptions can be raised when required,

<li> the number of calls to the subprogram can be checked.

</ul>

<p>The <a href="http://coldframe.sourceforge.net/coldframe/stubs.html">stubbing
facilities</a>
of <a href="http://sourceforge.net/projects/coldframe/">ColdFrame</a>
meet the above requirements.

<h2>Description</h2>

<p>The components of the package are <i>Commands</i>, <i>Events</i>,
and an <i>Event Queue</i>.

<h3>Commands</h3>

<p>A Command implements a Tcl command.

<p>It creates an Event to be executed at run time, and posts it on the
Event Queue.

<p><a href="#provided-commands">Some commands</a> are provided by this
package. Other commands are to be provided to support the specific
application to be tested:
typically, <tt>call_<i>procedure</i> <i>param1</i> <i>param2</i>
...</tt>  (where the parameters are those required by
<i>procedure</i>) and <tt>check_<i>subprogram</i> <i>parameter</i>
<i>value</i></tt> (to check the value passed to <i>procedure</i> in
<i>parameter</i> on the last call).

<!-- XXX do they need to know all this? -->
<p>Commands have to be <tt>Register</tt>ed with this package, because
once Tcl has been started (using <tt>Start</tt>, which doesn't return)
no more Commands can be added. Registration would normally be done
during elaboration of the package in which the Command is defined
(see <tt>test/test-first.adb</tt> in the distribution); <tt>Start</tt>
completes the registration with the Tcl interpreter.

<h3>Events</h3>

<p>An Event carries the data required to enact the command at run time.

<p>When it is executed, it performs the required action.

<ul>

<li>If all is well, it completes normally.

<li>If some condition fails, it raises an exception
(<tt>Execution_Failure</tt>) with a message stating the problem.

<li>Any other exceptions are propagated.

</ul>

<h3>Event Queue</h3>

<p>When the Event Queue is started (using the <tt>go</tt> command), it
repeatedly picks the next Event and executes it, until either the end
of the queue is reached (which implies that the script has succeeded)
or an exception is propagated (which implies that the script has
failed).

<a name="provided-commands"><h2>Provided commands</h2></a>

<p>The commands provided by this package are

<dl>

<dt><tt>echo "<i>string</i>"</tt> <dd>outputs <tt><i>string</i></tt>
to the terminal at run time. Useful to report the script's progress.

<dt><tt>wait <i>duration</i></tt> <dd>delays
for <tt><i>duration</i></tt>.

<dt><tt>mark <i>name</i></tt> <dd>notes the time at which the command
was executed.

<dt><tt>wait_from_mark <i>name</i> <i>duration</i></tt> <dd>delays until
<tt><i>duration</i></tt> after the <tt><i>name</i></tt>d mark. It is
an error if the indicated time has already passed. The mark can be
re-used.

<dt><tt>go</tt> <dd>start executing the script.

</dl>

<h2>Building</h2>

<p>A <a href="http://docs.adacore.com/gprbuild-docs/html/gprbuild_ug.html">GNAT
Project (GPR) file</a> (<tt>scripted_testing.gpr</tt>) is provided. To
build the library, say
<pre>
gprbuild -p -P scripted_testing
</pre>

<p>To install at your compiler's standard place, say this (you may
need to do so as <tt>root</tt>, via e.g.<tt>sudo</tt>). <b>DO NOT</b>
do this if you're using the compiler supplied with Debian-based
systems.
<pre>
make install
</pre>

<p>To install in (for example) <tt>~/local</tt>, say
<pre>
make install prefix=~/local
</pre>
<p>(and remember to put <tt>~/local/lib/gnat</tt> on
your <tt>ADA_PROJECT_PATH</tt>).

<p>Your own GPR should then include <tt>with "scripted_testing";</tt>

<p><hr>
<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i>
</body>
</html>
